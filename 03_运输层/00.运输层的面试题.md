>1. **端口和套接字的意义**
>2. **UDP 和 TCP 的区别以及两者的应用场景**
>3. **在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议**
>4. **TCP 的滑动窗口，流量控制，拥塞控制和连接管理**
>5. **TCP 的三次握手，四次挥手机制**

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

#### TCP和UDP的特点

- UDP

  - **无连接；不可靠；无拥塞控制 ；面向报文；支持一对一/一对多和多对多的交互通信**

  >用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

- TCP

  - **面向连接；可靠交付；有流量控制、有拥塞机制；面向字节流；支持点对点通信、提供全双工通信**

  >传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

- 什么是无连接？

  发送数据之前需不需要建立连接

- 什么是不可靠

  接收方接收到报文之后，需不需要给出确认收到的反馈信息

#### UDP首部格式

![image-20201112110123066](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-10-19/image-20201112110123066.png)

UDP包头包括源端口号和目标端口号

#### TCP首部格式

![image-20201112111137231](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-10-19/image-20201112111137231.png)

**包的序号**：编号是解决乱序的问题，TCP要了解到谁先来谁后来的

**确认序号**：为了解决不丢包的问题，因为TCP要知道自己发出去的包对方有没有收到

**状态位**：SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

**窗口大小**：TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力

#### TCP和UDP如何做选择

对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，**HTTP都是用TCP**，因为要求传输的内容可靠，不出现丢失

UDP应用场景

>1：需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
>
>2：不需要一对一沟通，建立连接，而是可以广播的应用。
>
>3：处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前
>的时候。

#### 面向连接和无连接的区别

#### TCP如何保证传输的可靠性

#### 三次握手

TCP 的连接建立，我们常常称为三次握手。
A：您好，我是 A。
B：您好 A，我是 B。
A：您好 B。

“请求 -> 应答 -> 应答之应答”

>首先，为什么要三次，而不是两次？按说两个人打招呼，一来一回就可以了啊？为了可靠，为什么不是四次？
>我们还是**假设这个通路是非常不可靠的**，A 要发起一个连接，当发了第一个请求杳无音信的时候，会有很多的可能性:
>
>​	1：比如第一个请求包丢了
>
>​	2：再如没有丢，但是绕了弯路，超时了
>
>​	3：还有 B 没有响应，不想和A连接。
>A 不能确认结果，于是再发，再发。终于，有一个请求包到了 B，但是请求包到了 B 的这个事情，目前A 还是不知道的，A 还有可能再发。
>B 收到了请求包，就知道了 A 的存在，并且知道 A 要和它建立连接。
>
>如果 B 不乐意建立连接，则 A 会重试一阵后放弃，连接建立失败，没有问题；
>
>如果 B 是乐意建立连接的，则会发送应答包给 A。
>
>当然对于 B 来说，这个应答包也是一入网络深似海，不知道能不能到达 A。这个时候 B 自然不能认为连接是建立好了，因为应答包仍然会丢，会绕弯路，或者 A 已经挂了都有可能。
>
>而且这个时候 B 还能碰到一个诡异的现象就是，A 和 B 原来建立了连接，做了简单通信后，结束了连接。还记得吗？A 建立连接的时候，请求包重复发了几次，有的请求包绕了一大圈又回来了，B 会认为这也是一个正常的的请求的话，因此建立了连接，可以想象，这个连接不会进行下去，也没有个终结的时候，纯属单相思了。
>
>因而两次握手肯定不行。
>B 发送的应答可能会发送多次，但是只要一次到达 A，A 就认为连接已经建立了，因为对于 A 来讲，他的消息有去有回。A 会给 B 发送应答之应答，而 B 也在等这个消息，才能确认连接的建立，只有等到了这个消息，对于 B 来讲，才算它的消息有去有回。
>
>当然 A 发给 B 的应答之应答也会丢，也会绕路，甚至 B 挂了。按理来说，还应该有个应答之应答之应答，这样下去就没底了。
>
>所以四次握手是可以的，四十次都可以，关键四百次也不能保证就真的可靠了。只要双方的消息都有去有回，就基本可以了。
>好在大部分情况下，A 和 B 建立了连接之后，A 会马上发送数据的，一旦 A 发送数据，则很多问题都得到了解决。例如 A 发给 B 的应答丢了，当 A 后续发送的数据到达的时候，B 可以认为这个连接已经建立，或者 B 压根就挂了，A 发送的数据，会报错，说 B 不可达，A 就知道 B 出事情了。
>
>当然你可以说 A 比较坏，就是不发数据，建立连接后空着。我们在程序设计的时候，可以要求开启
>keepalive 机制，即使没有真实的数据包，也有探活包。
>另外，你作为服务端 B 的程序设计者，对于 A 这种长时间不发包的客户端，可以主动关闭，从而空出资源来给其他客户端使用。
>
>三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是**TCP 包的序号**的问题。
>A 要告诉 B，我这面发起的包的序号起始是从哪个号开始的，B 同样也要告诉 A，B 发起的包的序号起始是从哪个号开始的。为什么序号不能都从 1 开始呢？因为这样往往会出现冲突。
>例如，A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，或者绕路了，于是重新发送，后来 A 掉线了，重新连上 B 后，序号又从 1 开始，然后发送 2，但是压根没想发送 3，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。
>因而，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4ms 加一，如果计算一下，如果到重复，需要 4 个多小时，那个绕路的包早就死翘翘了，因为我们都知道 IP 包头里面有个 TTL，也即生存时间。
>
>好了，双方终于建立了信任，建立了连接。前面也说过，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。

![image-20201112112133578](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-10-19/image-20201112112133578.png)

>一开始，客户端和服务端都处于 CLOSED 状态。
>
>先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。
>
>服务端收到发起的连接，返回 SYN，并且ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。
>
>客户端收到服务端发送的 SYN 和 ACK 之后，发送ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。
>
>服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。

#### 四次挥手

A：我要挂了

B：你要挂了啊

B：那我也挂了

A：好的，拜拜

因为在上述过程中，存在在每一个时刻两位都有跑路的可能，所以TCP协议专门有几个状态来处理这些问题，可以看如下的时序图：

![image-20201112145630698](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-10-19/image-20201112145630698.png)

>断开的时候，我们可以看到，当 A 说“不玩了”，就进入 FIN_WAIT_1 的状态，B 收到“A 不玩”的消
>息后，发送知道了，就进入 CLOSE_WAIT 的状态。
>
>A 收到“B 说知道了”，就进入 FIN_WAIT_2 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状
>态。TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设
>置一个超时时间。
>
>如果 B 没有跑路，发送了“B 也不玩了”的请求到达 A 时，A 发送“知道 B 也不玩了”的 ACK 后，从
>FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是最后的这个 ACK 万一 B 收不到呢？则 B 会重新发一
>个“B 不玩了”，这个时候 A 已经跑路了的话，B 就再也收不到 ACK 了，因而 TCP 协议要求 A 最后等
>待一段时间 TIME_WAIT，这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发
>的，A 会重新发一个 ACK 并且足够时间到达 B。
>
>A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还
>在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序
>列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来
>B 发送的所有的包都死翘翘，再空出端口来。
>
>等待的时间设为 2MSL，MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网
>络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个
>TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数
>据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30
>秒，1 分钟和 2 分钟等。
>
>还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照
>TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么
>长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。

#### TCP如何实现可靠机制

https://blog.csdn.net/liuchenxia8/article/details/80428157

#### TCP如何实现流量控制

#### TCP如何实现拥塞机制

#### 参考

https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md

https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md